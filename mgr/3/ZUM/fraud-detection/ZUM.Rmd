---
title: "ZUM"
output:
  html_document:
    df_print: paged
---

## Pakiety

```{r, message = FALSE}
library("tidyverse")
library("mlr3verse")
library("future")
library("progressr")
library("progress")
library("data.table")
```

## Kod pomocniczy

```{r, message = FALSE}
source("src/data_preparation.R")
source("src/helpers.R")
```

## Konfiguracja

```{r}
plan(list("multisession", "sequential"))
handlers("progress")
```


## Wczytanie danych

```{r}
data <- read_csv("data/creditcard.csv", col_types = c("Class" = "factor"))
data$Class <- factor(data$Class, labels = c("legit", "fraud"))
data
```

```{r}
# tymczasowo wybierzmy mniej danych żeby szybciej się liczyło
data <- data %>%
  group_by(Class) %>%
  slice_sample(n = 100, replace = TRUE) %>%
  ungroup()
```


## Koszt

```{r}
costs <- cost_matrix(data)
costs
```

## Przygotowanie danych

```{r}
data_minmax <- build_class_task(data, "minmax", id = "minmax")
data_minmax
```
```{r}
data_zscore <- build_class_task(data, "zscore", id = "zscore")
data_zscore
```

```{r}
data_robust <- build_class_task(data, "robust", id = "robust")
data_robust
```

## Wizualizacja danych

### MinMax {.tabset}

```{r, results='asis', echo = FALSE}
plot_features_in_tabs(data_minmax)
```

### Zscore {.tabset}

```{r, results='asis', echo = FALSE}
plot_features_in_tabs(data_zscore)
```

### Robust {.tabset}

```{r, results='asis', echo = FALSE}
plot_features_in_tabs(data_robust)
```


## Miara ewaluacyjna

```{r}
MeasureClassifCostsPatched <- R6::R6Class("MeasureClassifCostsPatched",
  inherit = MeasureClassifCosts,
  public = list(
    initialize = function(...) {
      super$initialize(...)
      self$properties <- character()
    }
  )
)
mlr_measures$add("classif.costs.patched", MeasureClassifCostsPatched)
```


```{r}
measure <- msr("classif.costs.patched", costs = costs)
measure
```

## Modele

### Baseline

```{r}
baseline <- learner("classif.featureless", method = "sample", id = "featureless")
```


### K najbliższych sąsiadów

```{r}
knn <- tunehyperparams(
  learner = tunethreshold(learner("classif.kknn"), id = "knn"),
  measure = measure,
  search_space = ps(
    classif.kknn.k = p_int(1, 30),
    classif.kknn.kernel = p_fct(c("rectangular", "epanechnikov", "inv", "gaussian"))
  )
)
```

### Maszyna wektorów nośnych

```{r}
svm <- tunehyperparams(
  learner = tunethreshold(learner("classif.ksvm", type = "C-svc"), id = "svm"),
  measure = measure,
  search_space = ps(
    classif.ksvm.kernel = p_fct(c("rbfdot", "polydot", "vanilladot")),
    classif.ksvm.sigma = p_dbl(0.01, 100, depends = classif.ksvm.kernel %in% c("rbfdot")),
    classif.ksvm.scale = p_dbl(0.01, 100, depends = classif.ksvm.kernel %in% c("polydot")),
    classif.ksvm.C = p_dbl(1, 100)
  )
)
```

### Regresja logistyczna

```{r}
logreg <- tunethreshold(learner("classif.log_reg"), id = "logreg")
```

### Drzewo decyzyjne

```{r}
rpart <- tunehyperparams(
  learner = tunethreshold(learner("classif.rpart"), id = "tree"),
  measure = measure,
  search_space = ps(
    classif.rpart.cp = p_dbl(0, 1),
    classif.rpart.maxdepth = p_int(1, 30),
    classif.rpart.minbucket = p_int(1, 100)
  )
)
```

### Las losowy

```{r}
random_forest <- tunehyperparams(
  learner = tunethreshold(learner("classif.ranger"), id = "randomforest"),
  measure = measure,
  search_space = ps(
    classif.ranger.num.trees = p_int(10, 1000),
    classif.ranger.max.depth = p_int(1, 30),
    classif.ranger.mtry = p_int(1, 30),
    classif.ranger.min.node.size = p_int(1, 10)
  )
)
```

## Benchmark

```{r}
tasks <- list(data_minmax, data_zscore, data_robust)
```

```{r}
learners <- list(baseline, knn, svm, logreg, rpart, random_forest)
```

```{r}
design <- benchmark_grid(
  tasks = tasks,
  learners = learners,
  resamplings = rsmp("cv", folds = 3)
)
design
```

```{r, warning=FALSE, attr.output='style="max-height: 500px;"'}
bmr <- with_progress(benchmark(design))
```

## Ewaluacja

### Miara ewaluacyjna {.tabset}

```{r}
aggregate_benchmark(bmr, measure, descending = FALSE)
```

```{r, results='asis', echo = FALSE, warning = FALSE}
plot_tasks_in_tabs(bmr, measure = measure)
```

### ROC {.tabset}

```{r, results='asis', echo = FALSE, warning = FALSE}
plot_tasks_in_tabs(bmr, measure = measure, type = "roc", autolimit = FALSE)
```

### ROC AUC {.tabset}

```{r, warning = FALSE}
aggregate_benchmark(bmr, msr("classif.auc"))
```

```{r, results='asis', echo = FALSE, warning = FALSE}
plot_tasks_in_tabs(bmr, measure = msr("classif.auc"))
```

### PRC {.tabset}

```{r, results='asis', echo = FALSE, warning = FALSE}
plot_tasks_in_tabs(bmr, measure = measure, type = "prc", autolimit = FALSE)
```

### PR AUC {.tabset}

```{r, warning = FALSE}
aggregate_benchmark(bmr, msr("classif.prauc"))
```

```{r, results='asis', echo = FALSE, warning = FALSE}
plot_tasks_in_tabs(bmr, measure = msr("classif.prauc"))
```

### Precyzja {.tabset}

```{r}
aggregate_benchmark(bmr, msr("classif.precision"))
```

```{r, results='asis', echo = FALSE, warning = FALSE}
plot_tasks_in_tabs(bmr, measure = msr("classif.precision"))
```

### Czułość {.tabset}

```{r}
aggregate_benchmark(bmr, msr("classif.recall"))
```

```{r, results='asis', echo = FALSE, warning = FALSE}
plot_tasks_in_tabs(bmr, measure = msr("classif.recall"))
```

### F1 {.tabset}

```{r}
aggregate_benchmark(bmr, msr("classif.fbeta"))
```

```{r, results='asis', echo = FALSE, warning = FALSE}
plot_tasks_in_tabs(bmr, measure = msr("classif.fbeta"))
```

### Czas trenowania {.tabset}

```{r, results='asis', echo = FALSE, warning = FALSE}
plot_tasks_in_tabs(bmr, measure = msr("time_train"))
```
